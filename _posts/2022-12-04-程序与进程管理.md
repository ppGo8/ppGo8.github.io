---
layout: mypost
title: 程序与进程管理
categories: [Linux]
---

# 程序与进程管理

## 任务管理

​		Linux操作系统是多任务操作系统，可以同时执行多个程序。但是通常每个用户登录服务器后只有一个终端环境，**要在一个终端执行多个任务**，就需要进行任务管理。

###  **任务管理的意义**

​		有些命令输入之后回车就可以返回结果，之后可以继续输入其他命令。也有些命令，如nano文本编辑器，执行该命令后会进步编译器环形，再执行其他命令就需要先退出nano编辑器，返回到终端环境中才可以。

​		在图形界面中，如果需要同时执行多个命令，可以采用开启多个终端的做法来实现，每个终端执行一个命令即可，例如同时执行两个nano程序，打开两个文件同时践行编辑。

​		在字符界面环境中只有一个终端，此时如果需要执行两个nano编辑器是无法再打开一个终端的。Linux操作系统提供了很多实用的命令来实现任务管理，也可以将运行的程序在前台和后台之间切换，已达到多任务同时运行的目的。

### 后台执行程序

​		当执行一个耗时比较长的程序时，如果还希望做一些其他工作，可以直接**让该程序在后台运行**，bash环境中可以使用`&`符号实现这一点。

- 使用tar命令在后台打包pp目录

  ![image-20221203114316509](F:\typora文件\typora图片存放\image-20221203114316509.png)

  ​		在上述示例中，实现了tar命令在后台执行，并返回工作号码的功能。

  ​		但需要注意示例中黄色框的部分，这部分内容是tar命令执行过程中的输出信息。虽然tar命令是在后台执行，但其执行过程中所产生的信息依然会输出到屏幕上，如果此时还在执行别的命令，将会造成**两条命令的输出信息冲突**，信息显示混乱。因此对于有输出的程序，直接添加`&`符号进行后台执行并不是很完美。此时可以同时使用重定向“`>`”符号进行解决，将tar命令所有输出重定向到一个日志文件中即可，示例如下。

- 使用重定向接受tar命令信息

  ![image-20221203120105480](F:\typora文件\typora图片存放\image-20221203120105480.png)

  ​		上述示例中，tar命令实现了后台执行，屏幕上也并没有输出任何tar命令运行过程中的信息，且所有信息都已经被重定向到了`/tmp/pp_tar.log`文件中，该命令由四部分组成。

  - 命令

    命令的作用是将pp文件夹打包，并保存为pp.gz.tar文件

  - 重定向tar信息

    将tar命令运行过程中输出的**所有标准输出信息**重定向到/tmp/pp_tar.log文件汇总

  - 重定向错误信息

    第一个重定向中，只是重定向了tar命令运行过程中的标准输出信息，词条命令并没有输出错误信息，所以该部分的重定向并不是必须的。但是**对于一些含有错误信息的任务，必须添加上该部分，实现错误信息的重定向**。

    该例实现了将**错误信息重定向到标准输出中**，而标准输出在之前已经被重定向到了`/tmp/pp_tar.log`文件中，所以错误的信息就**经过两次重定向**被重定向到了`/tmp/pp_tar.log`中，实现了错误信息的记录。

  - 后台执行符号

    指示该命令为后台执行，执行后会输出工作号码和进程PID，并将程序切换到后台

### 后台暂停程序

​		实现两个nano编辑器同时运行的问题，可以使用**Ctrl+T、Ctrl+Z组合键将正在执行的程序切换到后台**，之后再使用jobs、fg等命令对后台程序进行管理。

- 打开第一个nano程序并切换后台

  - 首先在终端输入

  ```
  nano pptest.txt
  ```

  - 之后进入nano编辑器环境，输入以下内容后，首先按Ctrl+T，然后按住Ctrl+Z，将nano程序切换到后台运行。

  ![image-20221203123919381](F:\typora文件\typora图片存放\image-20221203123919381.png)

  - 返回之后终端界面如下。

    ![image-20221203124049599](F:\typora文件\typora图片存放\image-20221203124049599.png)

     	切换之后前台输出信息主要包含一个提示信息“使用fg返回nano”和一条状态信息“[1]+已停止 nano pptest.txt”。

    - 第一条提示信息：fg是一个命令，作用是将后台程序切换到前台

    - 第二条状态信息：主要显示了当前运行状态为已停止，通过该命令可以看出当前程序在后台已经暂停，而不是继续运行。

  ​	    使用同样的方法创建第二个nano程序，并切换到后台执行，此处不再演示，第二个nano程序的工作号码应该是2。当创建了许多后台程序后，**可以使用jobs命令查看后台程序**。

  

- 使用jobs查看后台程序

  ![image-20221203125030599](F:\typora文件\typora图片存放\image-20221203125030599.png)

  以上示例中，两个后台程序出了工作号码不同外，工作号码之后的两个符号也不相同，即+和-。其中

  - +号：最后被切换到程序的程序，单独执行fg命令不指定工作号码默认切换到前台的程序
  - -号：倒数第二个被切换到后台的程序

  如果有3个以上的后台程序，则最早切换到后台的程序不再标注+、-符号，统一空白。

  

- 使用fg命令将后台程序切换到前台

  ![image-20221203125405473](F:\typora文件\typora图片存放\image-20221203125405473.png)

  ​		在上述示例中，直接输入fg命令，将会把最近的切换到后台的程序重新切换到前台。如果在fg后面添加上数字参数，则会将指定的程序切换到前台。

  

### 启动后台暂停程序

​		使用Ctrl+Z的组合键切换到后台的程序都会暂停运行，对于一些程序，比如nano编辑器来说，这是没问题的。但是对于其他一些任务，如下载任务，及时切换到后台，依然希望能够继续运行、继续下载，此时可以使用bg命令启动在后台已经暂停的程序。

- 使用wget命令在后台下载QQ文件

  ![image-20221203220516794](F:\typora文件\typora图片存放\image-20221203220516794.png)



### 删除后台程序

​		当后台程序执行错误或者其他原因不希望其继续执行时，可以将程序切换到前台，再正常关闭该程序或者按Ctrl+C组合键，强制将程序进行关闭。但是这些方法都是必须切换到前台才可以进行，很多时候可能想直接结束掉一个程序，此时可以使用kill命令来讲后台程序删除（杀死)。

```
kill,常用选项:
-l: 英文字符，列出目前kill命令可用的信号
-1: 数字1，对应SIGHUP信号，重新读取一次参数配置
-2: 数字2，对应SIGINT信号，执行和Ctrl+C组合键相同的操作
-9: 数字9，对应sigkill信号，强制杀死一个程序
-15: 数字15，对应SIGTERM信号，以正常方式终止一个任务，也是kill命令的默认值
```

![image-20221203220803899](F:\typora文件\typora图片存放\image-20221203220803899.png)

### 程序后台脱机运行

​		上述所有的示例中，即使一些程序已经切换到了后台运行，实际也只是在**终端环境下的后台**，**一旦关闭功终端，无论是前台还是后台的程序都会被结束掉。**如果是远程连接的方式连接到远程主机进行工作，**一旦网络环境不稳定造成一次脱机**，那么所有的工作都将被强制结束，下次登录时需要重新开始，很显然这是无法接受的。所以对于一些需要长时间运行的任务，可以切换到**系统后台中执行，终端关闭后，依然可以执行**，该操作使用screen命令来实现。

​		screen是一款由GUN计划开发的用于**命令行终端切换的自由软件**。用户可以通过该软件同时连接多个本地或远程的命令会话行，并在期间自由切换。只要screen本身没有被终止掉，其中运行的所有任务都可以被恢复，即使网络终端，只要再次登录，使用screen命令就可以找回上次正在运行的程序。

```
screen命令,常用选项
-A:将所有的视窗都调整为目前终端机的大小
-d:将指定的screen作业离线
-r:恢复离线的screen作业
-R:先试图恢复
-S:指定screen环境的名称
-x:恢复之前离线的screen环境
-ls或--list:
```

​		screen命令可以创建多个环境，从一个screen环境中退出，通常使用Crtl+A+Z组合键。接下来依然以下载QQ镜像为例，演示如何使用Ubuntu命令实现任务的后台运行且不会因终端关闭而结束进程。

```
-A: 将所有的视窗都调整为目前终端机的大小
-d: 将指定的screen作业离线
-r: 恢复李晓妮的screen作业
-R: 先试图恢复离线的作业，若找不到离线的作业，即建立新的screen环境
-S: 指定screen环境名称
-x: 恢复之前离线的screen环境
-ls: 显示目前所有的screen环境
```

- 在screen环境中创建后台下载任务

![image-20221204002045447](F:\typora文件\typora图片存放\image-20221204002045447.png)



- 返回上一示例中screen环境

  ![image-20221204002245570](F:\typora文件\typora图片存放\image-20221204002245570.png)

  返回之后会发现，下载并没有暂停，一直在下载。

  （此处由于在暂停之前就下载好了，所以返回之后下载的结果也是已经结束了的）

  

## 进程管理

​		每一个程序在执行时，都需要占用一定的系统资源，如CPU时间、内存空间等，所有的系统资源成为进程，**进程是系统进行资源分配的基本单位**。

### 查看进程

​		Linux操作系统提供了许多命令来进行进程的查看及管理，常用的有`ps、pstree、top`命令。

- ps命令

  ps命令的作用**是将命令执行一瞬间的进程运行获取并显示出来**，常用选项如下

  ```
  -A : 显示所有进程,-e与-A作用相同
  -a : 显示与终端无关的进程
  -f : 显示稍微完整的信息，比-l显示的信息要少
  -l : 详细显示进程信息
  ```

  - 使用ps命令显示进程

    ![image-20221203173615690](F:\typora文件\typora图片存放\image-20221203173615690.png)

    单纯执行ps命令，会显示和当前用户有关的进程信息。

  - 使用ps -l 命令显示进程的详细信息

    ![image-20221203173710579](F:\typora文件\typora图片存放\image-20221203173710579.png)

    上述事例中，每一项就进程都包括14项信息，含义如下：

    ```
    F : flag,进程标志,说明进程权限
    S : stat,代表进程状态,S代表睡眠，R代表运行,T代表停止,D不可被唤醒的睡眠,Z表示僵尸状态
    UID : 进程所属用户UID
    PID : 进程运行的ID号
    PPID : 该进程的父ID号
    C : CPU使用率，单位是百分比
    PRI : priority,进程优先级,优先级的数字越小,越快被执行
    NI :  nice,和PRI项一起构成进程的优先级
    ADDR : 进程在内存中所占的位置，如果正在运行，则表示为-
    SZ : 进程所占用的内存量
    WCHAN : 代表目前进程是否运行，运行则为-
    TTY : 登陆者的终端机的位置，远程登录使用动态终端接口与（pts/n)
    TIME : 进程占用的CPU时间
    CMD : 进程是由CMD程序执行而来
    ```

- pstree命令

  ​		ps命令显示的进程都是单独的，不能显示进程的归属。pstree作用是**以树形的方式显示进程的归属信息。**直接使用pstree命令即可，后面接-p选项能够在进程名称后输出相应的PID。

  ![image-20221203174905756](F:\typora文件\typora图片存放\image-20221203174905756.png)

  

- top命令

  ​		之前的两个命令ps和pstree都是以静态的方式显示Linux操作系统中的进程信息，只能显示某个时间点的状态，而top命令则是动态的、可定时刷新、可交互的进程查看器。在top命令执行的过程中，**可以使用键盘和top进行交互**，**常用按键如下**：

  ```
  ? : 显示top执行过程中可以按的案件
  P : 按cpu资源占有率进行排序
  M : 按内存资源占有由率进行排序
  N : 以PID进行排序
  T : 由该进程使用CPU的累计时间进行排序
  q : 退出top命令
  ```

  - 使用top命令查看进程

    ![image-20221203175214695](F:\typora文件\typora图片存放\image-20221203175214695.png)

    进入top命令环境后，可以使用键盘和top命令进行交互。

    第一行主要显示系统信息。

    第二行主要显示系统进程数量额度统计信息。

    第三行主要显示CPU状态信息。

    第四行代表物理内存的使用比率，第五行代表虚拟内存的使用比率。

    

  - 使用top命令查看bash程序的资源占有率

    ![image-20221203175432424](F:\typora文件\typora图片存放\image-20221203175432424.png)



###  关闭进程

​		之前提到的kill程序删除后台程序，实际上是**关闭了该后台程序的进程，达到了删除目的**。

- 使用Kill命令关闭指定PID程序

![image-20221203183113200](F:\typora文件\typora图片存放\image-20221203183113200.png)

​		在上述示例中，首先创建一个后台任务，之后使用ps和grep命令查找nano命令查看nano的进程PID。之后使用kill杀死进程。

### 进程优先级

​			Linux操作系统会根据进程优先级进行排序，之后再分配CPU，内存等资源。Linux进程的优先级由两部分构成，即**内核优先级**和**NI值**，最终的优先级PRI值使内核优先级的值与NI值的和，优先级值越低，则该进程的优先级越高。其中，内核优先级是内核动态调整的，用户无法调整。用户可以调整的是进程的NI值，同时为了防止用户随意更改进程优先级，抢占系统资源或恶意降低他人优先级，**一般用户只能调整自己进程的NI值，且只能加不能减**。但root用户可以调整任意用户的进程，且可以加也可以加也可以减。新执行的命令可以使用nice命令更改NI值，已经运行的程序可以使用renice命令来进行NI值额度更改。

- 使用nice命令为新创建的进程修改NI值

  ![image-20221203184525132](F:\typora文件\typora图片存放\image-20221203184525132.png)

- 使用renice命令调整bash的NI值

  ![image-20221203184814739](F:\typora文件\typora图片存放\image-20221203184814739.png)

  ​		更改bash的NI值，ps进程的NI值被更改为5，这说明NI值的吊证是可以在“父进程→子进程”之间传递的，即ps进程继承了父进程bash的NI值。

### 系统资源查看

​		之前讲到可以使用top命令查看系统资源的占有率的情况，同时也显示了总体额度一些信息。除此之外，Linux还提供了其他专门用来查看**系统资源的命令**。

- 查看内存使用量

  ```
  free命令，常用选项如下
  -b : 以byte为单位显示信息
  -k : 以KB为单位显示信息
  -m : 以MB为单位显示信息
  -g : 以GB为单位显示信息
  ```

  ![image-20221203185144765](F:\typora文件\typora图片存放\image-20221203185144765.png)

- 查看系统与内核相关信息

  ```
  unmae命令,常用选项如下
  -s : 内核名称
  -r : 内核版本
  -m : 硬件信息，主要是CPU架构信息，如x86_64、i386
  -a : 显示所有信息，包括以上选项输出内容
  ```

  ![image-20221203185332195](F:\typora文件\typora图片存放\image-20221203185332195.png)

- 查看系统启动时间和工作负载

  ```
  uptime
  ```

  ![image-20221203190559863](F:\typora文件\typora图片存放\image-20221203190559863.png)

## 计划任务管理

​		Windows操作系统的计划任务或开机启动项就是计划任务，这些计划任务在满足预定的触发条件（时间、时间等）时就会执行相应的任务。在Linux操作系统中，也可以实现类似的计划任务。

### 单次计划管理

​		单次计划只会执行一次，执行完毕后，该计划会自动删除，是比较常用的一种方式。在Linux系统中，可以使用at命令来创建单次计划。

```
at 选项 时间参数 ,常用选项如下:
-m : 当at命令指定的任务完成后，以Email的方式通知用户任务完成
-l : 列出目前系统中当前用户的at调度中的任务
-d : 取消at调度中的任务
-c : 显示某项任务的实际命令内容
```

​		另外，at命令的时间参数设置很灵活，有多种方式可以选择，常用的时间参数如下

```
HH:MM   时间格式,如13：00,在该时间点执行任务，如果设置任务时已超过13:00,则明天执行
HH:MM YYYY-mm-dd   日期+时间格式，在指定日期指定时间执行任务
HH:MM[am|pm] + 数字[minutes|hours|days|weeks]  在某个时间点加上时间段才开始，比如：04pm+3days表示三天后的下午四点执行
```

- 使用at命令创建定时任务

  ![image-20221203200703439](F:\typora文件\typora图片存放\image-20221203200703439.png)

  ​		at命令设定的任务是在其默认的shell中执行的，是独自与用户终端环境的，任务将直接被系统直接接管。也就是说，设置好at热恩午后，该任务就会在系统后台存在，即用户脱机之后，任务同样可以定时执行，**所以当执行比较耗时的程序是，也可以使用at命令将其作为系统后台程序执行**。

- 查看当前登录用户的终端名称

  ![image-20221203200742672](F:\typora文件\typora图片存放\image-20221203200742672.png)

  ​		之前提到at执行任务是在at默认的Shell环境中，该环境和当前登录用户的终端并不是一个环境，因此echo命令执行时，之后的字符串只能在at命令默认的Shell中输出，**在当前登录用户的终端是看不到的**。所以需要重定向，将信息重定向到当前登录用户的终端环境中，这样在用户的终端中，就可以看到任务执行时输出额度信息。

  ​		除了将信息输出到用户终端中，也可以使用重定向方式将任务执行信息输出到自定义的日志文件中。

- 查看at命令设置的任务内容

  ​		查看当前at设置的任务列表可以使用-l选项，也可以使用atq(at quene)命令。

  

  ![image-20221203201226407](F:\typora文件\typora图片存放\image-20221203201226407.png)

- 删除at任务

  ​		删除at任务可以使用-d选项，或者是atrm（at remove）命令。如上述例子中显示了任务列表中包含任务号，可以使用atrm加任务号的方式直接删除对应任务。

​				![image-20221203201433882](F:\typora文件\typora图片存放\image-20221203201433882.png)

​		由于at命令的执行并不是在特定的某个用户Shell环境中，且at环境的任务在用户离线时仍能执行，很容易对系统安全产生威胁，所以Linux操作系统并不是所有用户都可以运行at命令来创建计划任务的。

​		通常会采用/etc/at.allow和/etc/at.deny两个文件来控制哪些用户可以使用at命令，在不同的法相版本中，并不一定是两个文件都存在的。

### 循环任务管理(未完成)

​		在工作过程中，经常会遇到任务需要循环执行的情况，比如工作日定时打卡上班、定时发送工作日报等。

​		循环任务可以使用crontab命令，和at命令使用不太相同，crontab命令主要作用是修改/var/spool/cron/crontabs目录中的任务列表文件，该任务列表文件名称与当前用户名同名。任务列表文件中记录了任务执行时间、命令内容等信息。

- 使用crontab命令编辑任务列表

  

  ![image-20221203202606210](F:\typora文件\typora图片存放\image-20221203202606210.png)

- 查看pp用户的任务列表文件

  

### 关机期间的计划管理

​		无论at还是crontab任务管理，都是在开始的情况下才有效的，如果出发任务的时间恰好在关机期间，那么开机后因为时间已经过去，任务便不再执行。对于7*24小时午休的服务器来说，影响不大，但是对于个人计算机，由于关机时间不固定的问题，将会总成任务执行失败的问题。

​		为了解决这个问题，Linux操作系统系统了anarcon命令来对任务进行监测，一旦**检测到有任务在关机期间应该执行而没有执行**，便会重新执行该任务。anacron会以一天、一周、一个月为单位去检测系统中为践行的crontab任务，所以anacron本身并不具有管理任务计划的能力，只是能够检测crontab的任务计划而已。实际上，anacron命令的执行，也已经被安排到了crontab任务计划中。

* 查看crontab任务计划中的anacron计划

  ![image-20221203203802709](F:\typora文件\typora图片存放\image-20221203203802709.png)

  ​		由上述示例可以看出，anacron命令会按天、周、月执行，执行命令为”anacron -u +对应的文件“，该命令的作用是更新对应文件的时间戳。

  ​		对于anacron命令，时间戳是一个非常重要的信息，anacron命令通常会通过上述文件时间戳与当前时间的对比来确定是否有关机操作，然后判断是否需要执行某项任务计划。常用的anacron命令选项如下：

  ```
  -s:根据时间戳判断是否需要执行,需要执行则按顺序执行
  -f:不判断时间戳,直接顺序执行所有任务计划
  -n:立刻执行还未执行的操作
  -u:更新时间记录文件的时间戳,不做任何工作
  ```

  ​		上述示例中使用-u选项更新了cron.daily文件的时间戳，而没有进行其他的工作。下一次将会以本次更新的会见戳为判断是否需要执行。

## 系统服务管理

​		Windows操作系统下的服务包括各种驱动程序、输入法、管家程序都会在开机后依次启动，并以系统服务的形式进行。在Linux操作系统中，也存在大量的服务，本节就简单介绍Linux操作系统中服务的管理。

### systemd简介

​		服务是常驻在系统中**提供特定功能的应用程序（daemon)**，例如，循环计划任务管理服务由程序crond(daemon)提供。一般任务服务和daemon是相同的。

​		init是UNIX和类UNIX系统中用来产生其他所有进程的应用程序。init进程的进程号是1，是Linux内核启动后第一个运行的程序，之后再由init进行加载服务、启动shell、启动图形化界面工作等。在关机时，init又负责关闭服务等操作。

​		systemd是Ubuntu操作系统中负责init工作的这样一套程序。目前绝大多数Linux发行版都已经采用了systemd代替了init程序。systemd将daemon统称为服务单元（unit),不同的unit按功能区分为不同的类型（type)。**常见的基本类型包括系统服务、数据监听和socket、储存系统等类型**。

- 查看systemd进程

  ![image-20221203205225549](F:\typora文件\typora图片存放\image-20221203205225549.png)

  systemd包含了一组常用命令，**实现对系统各项资源的查看与控制**，部分命令如下

  ```
  systemctl:systemd主命令，对服务的管理主要使用该命令
  systemd-analyze:查看启动耗时
  hostnamectl:查看并修改当前主机信息
  localectl:查看并设置本地化设置参数
  timedatectl:查看并修改时间信息
  loginctl:查看登录用户信息
  ```

### systemctl简介

​		作为systemd主命令，systemd服务的绝大多数管理命令都是有systemctl实现。systemctl主要作用是**获取systemd服务返回信息或发送控制命令到systemd服务**。

​		systemtcl的众多功能大多依靠辅助指令来实现。辅助命令根据不同主要分为7大类：服务单元管理指令、服务单元文件管理指令、设备管理制定、工作计划管理制定、环境管理制定、daemon生命周期管理指令、系统管理指令。

```
systemctl常用辅助指令
status : 查看系统服务状态
list-units : 列出所有运行的服务
list-unit-files : 列出所有可用服务
start : 启动服务
stop : 关闭服务
restart : 重启服务 
enable : 启用服务，被启用的服务会在系统启动时自动启动
disable : 禁用服务，被禁用的服务在系统启动时不会自动启动
kill : 杀死某个服务
```

- 列出所有系统中正在运行的服务

  ![image-20221203210433978](F:\typora文件\typora图片存放\image-20221203210433978.png)

- 列出系统中所有的服务文件

  ![image-20221203210545512](F:\typora文件\typora图片存放\image-20221203210545512.png)

### 查看服务信息

​		Windows操作系统中提供了‘任务管理器’来查看服务的各项信息，即服务名称、描述、状态、所属组、PID等。在Linux操作系统中，可以使用systemctl命令的辅助命令status来查看服务的信息。下面以cron任务计划服务来演示服务信息的查看。

![image-20221203210740916](F:\typora文件\typora图片存放\image-20221203210740916.png)

### 服务的启动与关闭

​		服务作为一种应用程序，一般在系统启动时启动，同时也可以被手动关闭或重启。服务的启动、关闭使用systemctl中的start、stop、和restrat是三个辅助指令实现。下面以cron计划服务演示服务的启动和关闭。

- 关闭服务

  ![image-20221203211454602](F:\typora文件\typora图片存放\image-20221203211454602.png)

- 启动服务

  ![image-20221203211550007](F:\typora文件\typora图片存放\image-20221203211550007.png)

### 服务配置文件说明

​		由上述示例可知，每个服务都有对应的配置文件信息，该文件保存在`/lib/systemd/system`目录下，以`service`为拓展名。除了service外，`/lib/systemd/system/`下还保存了其他一些拓展名文件。

```
socket : socket通信使用的服务
target : 执行环境类型，多个服务单元的集合，可以同时拥有多个服务
mount/automount : 文件挂在相关的服务
path : 检测待定的文件或目录类型
timer : 功能类似anacrontab,但是由systemd提供并控制
```

- 查看cron.service文件内容

  ![image-20221203211944221](F:\typora文件\typora图片存放\image-20221203211944221.png)

  从上述内容可以看到，service文件大体分为**Unit、Service、Install**三部分

  - Unit部分

    ​		systemd将系统中的服务分为多种单元，service文件中第一大项就是该服务的单元信息以及该服务相关的设置。

  - Service部分

    ​		**Service是指单元类型**，除了服务类单元外，还包括如Socket、Timer、Mount等，不同的单元在此处需要不同的名字。

    这部分内容主要规范了服务启动的脚本位置、参数、关闭、停止方式等信息。

  - Install部分

    ​		target是一对服务的集合，选择执行特定的target，就是执行其所包含的各类服务，在上述示例中，`WantedBy=multi-user.target`就是将该服务加入到`multi-user.target`中，除了WantedBy之外，Install还包括以下两个选项。

### systemctl设置开机启动任务（未完成)

​		开机自启动是一项很方便的功能，Windows操作系统中大部分软件都可以在安装时选择是否开机自动启动，而Linux操作系统中**大部分在非必要的情况下都不会自动启动**，可以使用创建服务的方式间接实现程序的开机启动。

​		设置开机启动需要以下几个步骤。

- 在/etc/目录下创建开机任务的脚本

  ![image-20221203214359640](F:\typora文件\typora图片存放\image-20221203214359640.png)

  ![image-20221203214343987](F:\typora文件\typora图片存放\image-20221203214343987.png)

- 在/lib/systemd/system目录中创建启动服务

  ![image-20221203214925818](F:\typora文件\typora图片存放\image-20221203214925818.png)

  ![image-20221203214908402](F:\typora文件\typora图片存放\image-20221203214908402.png)

- 创建启动项

  ![image-20221203215037732](F:\typora文件\typora图片存放\image-20221203215037732.png)

- 重启验证是否创建启动项成功

  

  

​		







